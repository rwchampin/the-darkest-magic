'use strict'; function _typeof(t) { return (_typeof = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol' ? function (t) { return typeof t } : function (t) { return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t })(t) } function _defineProperty(t, e, a) { return e in t ? Object.defineProperty(t, e, { value: a, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = a, t } function _classCallCheck(t, e) {
  if (!(t instanceof e))
    throw new TypeError('Cannot call a class as a function')
} function _defineProperties(t, e) { for (let a = 0; a < e.length; a++) { const i = e[a]; i.enumerable = i.enumerable || !1, i.configurable = !0, 'value' in i && (i.writable = !0), Object.defineProperty(t, i.key, i) } } function _createClass(t, e, a) { return e && _defineProperties(t.prototype, e), a && _defineProperties(t, a), Object.defineProperty(t, 'prototype', { writable: !1 }), t } function _inherits(t, e) {
  if (typeof e != 'function' && e !== null)
    throw new TypeError('Super expression must either be null or a function'); Object.defineProperty(t, 'prototype', { value: Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), writable: !1 }), e && _setPrototypeOf(t, e)
} function _createSuper(a) { const i = _isNativeReflectConstruct(); return function () { let t; const e = _getPrototypeOf(a); return _possibleConstructorReturn(this, i ? (t = _getPrototypeOf(this).constructor, Reflect.construct(e, arguments, t)) : e.apply(this, arguments)) } } function _possibleConstructorReturn(t, e) {
  if (e && (_typeof(e) === 'object' || typeof e == 'function'))
    return e; if (void 0 !== e)
    throw new TypeError('Derived constructors may only return object or undefined'); return _assertThisInitialized(t)
} function _assertThisInitialized(t) {
  if (void 0 === t)
    throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called'); return t
} function _wrapNativeSuper(t) {
  const a = typeof Map == 'function' ? new Map() : void 0; return (_wrapNativeSuper = function (t) {
    if (t === null || !_isNativeFunction(t))
      return t; if (typeof t != 'function')
      throw new TypeError('Super expression must either be null or a function'); if (void 0 !== a) {
      if (a.has(t))
        return a.get(t); a.set(t, e)
    } function e() { return _construct(t, arguments, _getPrototypeOf(this).constructor) } return e.prototype = Object.create(t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), _setPrototypeOf(e, t)
  })(t)
} function _construct(t, e, a) { return (_construct = _isNativeReflectConstruct() ? Reflect.construct : function (t, e, a) { let i = [null]; i.push.apply(i, e); i = new (Function.bind.apply(t, i))(); return a && _setPrototypeOf(i, a.prototype), i }).apply(null, arguments) } function _isNativeReflectConstruct() {
  if (typeof Reflect == 'undefined' || !Reflect.construct)
    return !1; if (Reflect.construct.sham)
    return !1; if (typeof Proxy == 'function')
    return !0; try { return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], () => { })), !0 }
  catch (t) { return !1 }
} function _isNativeFunction(t) { return Function.toString.call(t).includes('[native code]') } function _setPrototypeOf(t, e) { return (_setPrototypeOf = Object.setPrototypeOf || function (t, e) { return t.__proto__ = e, t })(t, e) } function _getPrototypeOf(t) { return (_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) { return t.__proto__ || Object.getPrototypeOf(t) })(t) } function _classPrivateMethodInitSpec(t, e) { _checkPrivateRedeclaration(t, e), e.add(t) } function _classPrivateFieldInitSpec(t, e, a) { _checkPrivateRedeclaration(t, e), e.set(t, a) } function _checkPrivateRedeclaration(t, e) {
  if (e.has(t))
    throw new TypeError('Cannot initialize the same private elements twice on an object')
} function _classPrivateMethodGet(t, e, a) {
  if (!e.has(t))
    throw new TypeError('attempted to get private field on non-instance'); return a
} function _classPrivateFieldGet(t, e) { return _classApplyDescriptorGet(t, _classExtractFieldDescriptor(t, e, 'get')) } function _classApplyDescriptorGet(t, e) { return e.get ? e.get.call(t) : e.value } function _classPrivateFieldSet(t, e, a) { return _classApplyDescriptorSet(t, _classExtractFieldDescriptor(t, e, 'set'), a), a } function _classExtractFieldDescriptor(t, e, a) {
  if (!e.has(t))
    throw new TypeError(`attempted to ${a} private field on non-instance`); return e.get(t)
} function _classApplyDescriptorSet(t, e, a) {
  if (e.set) { e.set.call(t, a) }
  else {
    if (!e.writable)
      throw new TypeError('attempted to set read only private field'); e.value = a
  }
} const _VALID_DIRECTIONS = new WeakMap(); const _DEFAULT_DIRECTION = new WeakMap(); const _DEFAULT_ACCURACY = new WeakMap(); const _DEFAULT_RUNOFF = new WeakMap(); const _VALID_RANDOM_METHODS = new WeakMap(); const _DEFAULT_SCATTER_METHOD = new WeakMap(); const _DEFAULT_JITTER_METHOD = new WeakMap(); const _DEFINED_STYLES = new WeakMap(); const _globalParams = new WeakMap(); const _pointer = new WeakMap(); const _coords = new WeakMap(); const _styles = new WeakMap(); const _properties = new WeakMap(); const _nodes = new WeakMap(); const _nodeData = new WeakMap(); const _fpsTimerRef = new WeakMap(); const _init = new WeakSet(); const _setNodeIndexData = new WeakSet(); const _calculateJitters = new WeakSet(); const _runFrames = new WeakSet(); const _refresh = new WeakSet(); const ProximityEffect = (function () {
  _inherits(s, _wrapNativeSuper(EventTarget)); const i = _createSuper(s); function s(t) {
    let e; const a = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; if (_classCallCheck(this, s), _classPrivateMethodInitSpec(_assertThisInitialized(e = i.call(this)), _refresh), _classPrivateMethodInitSpec(_assertThisInitialized(e), _runFrames), _classPrivateMethodInitSpec(_assertThisInitialized(e), _calculateJitters), _classPrivateMethodInitSpec(_assertThisInitialized(e), _setNodeIndexData), _classPrivateMethodInitSpec(_assertThisInitialized(e), _init), _classPrivateFieldInitSpec(_assertThisInitialized(e), _VALID_DIRECTIONS, { writable: !0, value: new Set(['both', 'horizontal', 'vertical']) }), _classPrivateFieldInitSpec(_assertThisInitialized(e), _DEFAULT_DIRECTION, { writable: !0, value: 'both' }), _classPrivateFieldInitSpec(_assertThisInitialized(e), _DEFAULT_ACCURACY, { writable: !0, value: 5 }), _classPrivateFieldInitSpec(_assertThisInitialized(e), _DEFAULT_RUNOFF, { writable: !0, value: 100 }), _classPrivateFieldInitSpec(_assertThisInitialized(e), _VALID_RANDOM_METHODS, { writable: !0, value: new Set(['normal', 'uniform']) }), _classPrivateFieldInitSpec(_assertThisInitialized(e), _DEFAULT_SCATTER_METHOD, { writable: !0, value: 'uniform' }), _classPrivateFieldInitSpec(_assertThisInitialized(e), _DEFAULT_JITTER_METHOD, { writable: !0, value: 'uniform' }), _classPrivateFieldInitSpec(_assertThisInitialized(e), _DEFINED_STYLES, { writable: !0, value: { translateX: { default: 0, rule: 'transform', func: 'translateX', unit: 'px' }, translateY: { default: 0, rule: 'transform', func: 'translateY', unit: 'px' }, translateZ: { default: 0, rule: 'transform', func: 'translateZ', unit: 'px' }, rotate: { default: 0, rule: 'transform', func: 'rotate', unit: 'deg' }, rotateX: { default: 0, rule: 'transform', func: 'rotateX', unit: 'deg' }, rotateY: { default: 0, rule: 'transform', func: 'rotateY', unit: 'deg' }, rotateZ: { default: 0, rule: 'transform', func: 'rotateZ', unit: 'deg' }, scale: { default: 1, rule: 'transform', func: 'scale' }, scaleX: { default: 1, rule: 'transform', func: 'scaleX' }, scaleY: { default: 1, rule: 'transform', func: 'scaleY' }, scaleZ: { default: 1, rule: 'transform', func: 'scaleZ' }, skewX: { default: 0, rule: 'transform', func: 'skewX', unit: 'deg' }, skewY: { default: 0, rule: 'transform', func: 'skewY', unit: 'deg' }, blur: { min: 0, default: 0, rule: 'filter', func: 'blur', unit: 'px' }, brightness: { min: 0, default: 100, rule: 'filter', func: 'brightness', unit: '%' }, contrast: { min: 0, default: 100, rule: 'filter', func: 'contrast', unit: '%' }, grayscale: { min: 0, max: 100, default: 0, rule: 'filter', func: 'grayscale', unit: '%' }, hueRotate: { default: 0, rule: 'filter', func: 'hue-rotate', unit: 'deg' }, invert: { min: 0, max: 100, default: 0, rule: 'filter', func: 'invert', unit: '%' }, opacity: { min: 0, max: 100, default: 100, rule: 'filter', func: 'opacity', unit: '%' }, saturate: { min: 0, max: 100, default: 100, rule: 'filter', func: 'saturate', unit: '%' }, sepia: { min: 0, max: 100, default: 0, rule: 'filter', func: 'sepia', unit: '%' }, color: { min: 0, max: 255, default: [0, 0, 0], rule: 'color', func: 'rgb', args: 3 }, backgroundColor: { min: 0, max: 255, default: [0, 0, 0], rule: 'backgroundColor', func: 'rgb', args: 3 }, scale3D: { default: [1, 1, 1], rule: 'transform', func: 'scale3D', args: 3 } } }), _classPrivateFieldInitSpec(_assertThisInitialized(e), _globalParams, { writable: !0, value: void 0 }), _classPrivateFieldInitSpec(_assertThisInitialized(e), _pointer, { writable: !0, value: {} }), _classPrivateFieldInitSpec(_assertThisInitialized(e), _coords, { writable: !0, value: void 0 }), _classPrivateFieldInitSpec(_assertThisInitialized(e), _styles, { writable: !0, value: void 0 }), _classPrivateFieldInitSpec(_assertThisInitialized(e), _properties, { writable: !0, value: void 0 }), _classPrivateFieldInitSpec(_assertThisInitialized(e), _nodes, { writable: !0, value: void 0 }), _classPrivateFieldInitSpec(_assertThisInitialized(e), _nodeData, { writable: !0, value: void 0 }), _classPrivateFieldInitSpec(_assertThisInitialized(e), _fpsTimerRef, { writable: !0, value: void 0 }), !t)
      throw new Error('ProximityEffect: nodes argument is required.'); return e.preventCenterCalculations = !0, _classPrivateFieldSet(_assertThisInitialized(e), _globalParams, a), e.nodes = t, e.threshold = _classPrivateFieldGet(_assertThisInitialized(e), _globalParams).hasOwnProperty('threshold') ? _classPrivateFieldGet(_assertThisInitialized(e), _globalParams).threshold : 0, e.runoff = _classPrivateFieldGet(_assertThisInitialized(e), _globalParams).hasOwnProperty('runoff') ? _classPrivateFieldGet(_assertThisInitialized(e), _globalParams).runoff : _classPrivateFieldGet(_assertThisInitialized(e), _DEFAULT_RUNOFF), e.attack = _classPrivateFieldGet(_assertThisInitialized(e), _globalParams).hasOwnProperty('attack') ? _classPrivateFieldGet(_assertThisInitialized(e), _globalParams).attack : 1, e.decay = _classPrivateFieldGet(_assertThisInitialized(e), _globalParams).hasOwnProperty('decay') ? _classPrivateFieldGet(_assertThisInitialized(e), _globalParams).decay : 1, e.accuracy = _classPrivateFieldGet(_assertThisInitialized(e), _globalParams).hasOwnProperty('accuracy') ? _classPrivateFieldGet(_assertThisInitialized(e), _globalParams).accuracy : _classPrivateFieldGet(_assertThisInitialized(e), _DEFAULT_ACCURACY), e.invert = _classPrivateFieldGet(_assertThisInitialized(e), _globalParams).invert || !1, e.offsetX = _classPrivateFieldGet(_assertThisInitialized(e), _globalParams).offsetX || 0, e.offsetY = _classPrivateFieldGet(_assertThisInitialized(e), _globalParams).offsetY || 0, e.jitter = _classPrivateFieldGet(_assertThisInitialized(e), _globalParams).jitter || 0, e.jitterX = _classPrivateFieldGet(_assertThisInitialized(e), _globalParams).jitterX || 0, e.jitterY = _classPrivateFieldGet(_assertThisInitialized(e), _globalParams).jitterY || 0, e.direction = _classPrivateFieldGet(_assertThisInitialized(e), _globalParams).direction || _classPrivateFieldGet(_assertThisInitialized(e), _DEFAULT_DIRECTION), e.target = _classPrivateFieldGet(_assertThisInitialized(e), _globalParams).target, document.readyState === 'completed' ? _classPrivateMethodGet(_assertThisInitialized(e), _init, _init2).call(_assertThisInitialized(e)) : window.addEventListener('load', () => { return _classPrivateMethodGet(_assertThisInitialized(e), _init, _init2).call(_assertThisInitialized(e)) }), e
  } return _createClass(s, [{
    key: 'target',
    get() { return _classPrivateFieldGet(this, _globalParams).target },
    set(t) {
      if (t && !t.getBoundingClientRect())
        throw new Error('ProximityEffect: '.concat(t, ' is not a valid target.')); _classPrivateFieldGet(this, _globalParams).target = t
    },
  }, {
    key: 'nodes',
    get() { return _classPrivateFieldGet(this, _nodes) },
    set(t) {
      const e = this; if (!(t instanceof NodeList))
        throw new Error('ProximityEffect: '.concat(t, ' is not a node list.')); if (t.length < 1)
        throw new Error('ProximityEffect: No nodes found in '.concat(t, '.')); _classPrivateFieldSet(this, _nodes, [].slice.call(t)), _classPrivateFieldSet(this, _nodeData, _classPrivateFieldGet(this, _nodes).map((t) => { return { node: t, style: t.style.cssText, lastDelta: _classPrivateFieldGet(e, _globalParams).primeDistances ? 1 : null } })), _classPrivateFieldGet(this, _globalParams) && !this.preventCenterCalculations && this.setCenterPoints()
    },
  }, { key: 'styles', get() { return _classPrivateFieldGet(this, _styles) } }, { key: 'threshold', get() { return _classPrivateFieldGet(this, _globalParams).threshold }, set(t) { _classPrivateFieldGet(this, _globalParams).threshold = Adasha_Utils.constrain(t, 0) } }, { key: 'runoff', get() { return _classPrivateFieldGet(this, _globalParams).runoff }, set(t) { _classPrivateFieldGet(this, _globalParams).runoff = Adasha_Utils.constrain(t, 0), _classPrivateFieldGet(this, _globalParams).invRunoff = 1 / _classPrivateFieldGet(this, _globalParams).runoff } }, { key: 'boundary', get() { return this.threshold + this.runoff } }, { key: 'invert', get() { return _classPrivateFieldGet(this, _globalParams).invert }, set(t) { _classPrivateFieldGet(this, _globalParams).invert = !!t } }, { key: 'attack', get() { return _classPrivateFieldGet(this, _globalParams).attack }, set(t) { _classPrivateFieldGet(this, _globalParams).attack = Adasha_Utils.constrain(t, 0, 1) } }, { key: 'decay', get() { return _classPrivateFieldGet(this, _globalParams).decay }, set(t) { _classPrivateFieldGet(this, _globalParams).decay = Adasha_Utils.constrain(t, 0, 1) } }, { key: 'offsetX', get() { return _classPrivateFieldGet(this, _globalParams).offsetX }, set(t) { _classPrivateFieldGet(this, _globalParams).offsetX = t, this.preventCenterCalculations || this.setCenterPoints() } }, { key: 'offsetY', get() { return _classPrivateFieldGet(this, _globalParams).offsetY }, set(t) { _classPrivateFieldGet(this, _globalParams).offsetY = t, this.preventCenterCalculations || this.setCenterPoints() } }, { key: 'jitter', get() { return _classPrivateFieldGet(this, _globalParams).jitter }, set(t) { _classPrivateFieldGet(this, _globalParams).jitter = Adasha_Utils.constrain(t, 0), _classPrivateMethodGet(this, _calculateJitters, _calculateJitters2).call(this) } }, { key: 'jitterX', get() { return _classPrivateFieldGet(this, _globalParams).jitterX }, set(t) { _classPrivateFieldGet(this, _globalParams).jitterX = Adasha_Utils.constrain(t, 0), _classPrivateMethodGet(this, _calculateJitters, _calculateJitters2).call(this) } }, { key: 'jitterY', get() { return _classPrivateFieldGet(this, _globalParams).jitterY }, set(t) { _classPrivateFieldGet(this, _globalParams).jitterY = Adasha_Utils.constrain(t, 0), _classPrivateMethodGet(this, _calculateJitters, _calculateJitters2).call(this) } }, { key: 'jitterMethod', get() { return _classPrivateFieldGet(this, _globalParams).jitterMethod }, set(t) { _classPrivateFieldGet(this, _globalParams).jitterMethod = t, _classPrivateMethodGet(this, _calculateJitters, _calculateJitters2).call(this) } }, { key: 'direction', get() { return _classPrivateFieldGet(this, _globalParams).direction }, set(t) { _classPrivateFieldGet(this, _VALID_DIRECTIONS).has(t) ? _classPrivateFieldGet(this, _globalParams).direction = t : console.log('ProximityEffect: \''.concat(t, '\' is not a valid direction.')) } }, { key: 'FPS', get() { return _classPrivateFieldGet(this, _globalParams).FPS }, set(t) { _classPrivateFieldGet(this, _fpsTimerRef) && (window.clearInterval(_classPrivateFieldGet(this, _fpsTimerRef)), _classPrivateFieldSet(this, _fpsTimerRef, null)), typeof t == 'number' && t > 0 ? (_classPrivateFieldGet(this, _globalParams).FPS = Adasha_Utils.constrain(t, 0), _classPrivateMethodGet(this, _runFrames, _runFrames2).call(this)) : _classPrivateFieldGet(this, _globalParams).FPS = null } }, { key: 'accuracy', get() { return _classPrivateFieldGet(this, _globalParams).accuracy }, set(t) { _classPrivateFieldGet(this, _globalParams).accuracy = Math.floor(Adasha_Utils.constrain(t, 0)) } }, { key: 'pointer', get() { return { x: _classPrivateFieldGet(this, _pointer).x, y: _classPrivateFieldGet(this, _pointer).y } } }, {
    key: 'addStyle',
    value(t, e, a) {
      let i; if (typeof t == 'string') {
        if (!_classPrivateFieldGet(this, _DEFINED_STYLES).hasOwnProperty(t))
          throw new Error('ProximityEffect: Couldn\'t find preset \''.concat(t, '\'')); i = _classPrivateFieldGet(this, _DEFINED_STYLES)[t]
      }
      else {
        if (!Adasha_Utils.isObject(t))
          throw new Error('ProximityEffect: \''.concat(t, '\' is not a valid style rule.')); if (typeof t.rule != 'string')
          throw new Error('ProximityEffect: \''.concat(t, '\' object does not define a style rule.')); i = t
      } for (let s = 0; s < e.length; s++) {
        const r = e[s]; if (typeof r == 'number')
          switch (e[s] = Adasha_Utils.valToObj(Adasha_Utils.constrain(r, i.min, i.max)), s) { case 0: e[s].distance = 0; break; case e.length - 1: e[s].distance = 1 }
      } const n = e[0]; const l = e[e.length - 1]; _classPrivateFieldSet(this, _styles, _classPrivateFieldGet(this, _styles) || []); a = { rules: i, near: n, far: l, params: a }; _classPrivateFieldGet(this, _styles).push(a); for (let o = 0; o < _classPrivateFieldGet(this, _nodeData).length; o++) { const c = this.getNodeIndexData(o, 'styles') || _classPrivateMethodGet(this, _setNodeIndexData, _setNodeIndexData2).call(this, o, 'styles', []).styles; const d = n.scatterMethod || _classPrivateFieldGet(this, _DEFAULT_SCATTER_METHOD); const u = l.scatterMethod || _classPrivateFieldGet(this, _DEFAULT_SCATTER_METHOD); c.push({ near: n.scatter ? n.value + Adasha_Utils.random(n.scatter, d) : n.value, far: l.scatter ? l.value + Adasha_Utils.random(l.scatter, u) : l.value }) }
    },
  }, { key: 'hasStyle', value(e) { return void 0 !== this.styles.find((t) => { return t.type === e }) } }, {
    key: 'removeStyle',
    value(t) {
      if (this.hasStyle(t))
        for (let e = 0; e < _classPrivateFieldGet(this, _styles).length; e++)_classPrivateFieldGet(this, _styles)[e].type === t && _classPrivateFieldGet(this, _styles).splice(e, 1)
    },
  }, { key: 'addProperty', value(t, e) { _classPrivateFieldSet(this, _properties, _classPrivateFieldGet(this, _properties) || []); e = { name: t, params: e }; _classPrivateFieldGet(this, _properties).push(e) } }, { key: 'hasProperty', value() { } }, { key: 'removeProperty', value() { } }, { key: 'distanceFrom', value(t) { return this.getNodeData(t, 'distance') } }, { key: 'distanceFromIndex', value(t) { return this.getNodeIndexData(t, 'distance') } }, { key: 'clearTarget', value() { this.target = null } }, { key: 'getCoords', value() { return _classPrivateFieldGet(this, _coords) } }, { key: 'setCoords', value(t, e) { typeof t == 'Number' && typeof e == 'Number' || _classPrivateFieldSet(this, _coords, { x: t, y: e }) } }, { key: 'clearCoords', value() { _classPrivateFieldGet(this, _coords) && _classPrivateFieldSet(this, _coords, null) } }, { key: 'setCenterPoints', value() { for (let t = 0; t < this.nodes.length; t++) { const e = this.nodes[t]; const a = e.style.cssText; e.style.cssText = this.getNodeIndexData(t, 'style'); var i = e.getBoundingClientRect(); let s = 0.5 * (i.left + i.right) - this.offsetX; let r = 0.5 * (i.top + i.bottom) - this.offsetY; var i = this.getNodeIndexData(t, 'jitter'); i && (s += i.x, r += i.y), e.style.cssText = a, _classPrivateMethodGet(this, _setNodeIndexData, _setNodeIndexData2).call(this, t, 'center', { x: s, y: r }) } } }, { key: 'getNodeData', value(t, e) { const a = _classPrivateFieldGet(this, _nodeData)[this.nodes.findIndex((t) => { return t === node })]; return e ? a[e] : a } }, { key: 'getNodeIndexData', value(t, e) { return _classPrivateFieldGet(this, _nodeData)[t][e] } }, { key: 'hasNodeIndexData', value(t, e) { return _classPrivateFieldGet(this, _nodeData)[t].hasOwnProperty(e) } }, { key: 'updatePointer', value(t) { _classPrivateFieldGet(this, _pointer).x = t.clientX, _classPrivateFieldGet(this, _pointer).y = t.clientY } }, { key: 'reflowEvent', value(t) { const e = this; t.currentTarget !== this && this.dispatchEvent(new Event('reflow')), this.preventCenterCalculations || window.setTimeout(() => { return e.setCenterPoints() }, 1) } }, { key: 'update', value(t) { document.documentElement; for (let e = 0; e < this.nodes.length; e++) { var a; const i = this.nodes[e]; var s = (i.getBoundingClientRect(), this.getNodeIndexData(e, 'center')); var r = s.x - (i.dataset.offsetx || 0); var n = s.y - (i.dataset.offsety || 0); var l = void 0; var o = void 0; var s = this.getNodeIndexData(e, 'lastDelta'); o = _classPrivateFieldGet(this, _coords) ? (l = (a = this.getCoords()).x, a.y) : this.target ? (l = 0.5 * ((a = this.target.getBoundingClientRect()).left + a.right), 0.5 * (a.top + a.bottom)) : (l = this.pointer.x, this.pointer.y); var c; var l = l - r; var r = o - n; var o = void 0; var n = void 0; var o = this.direction === 'both' ? Adasha_Utils.pythagoras(l, r) : Math.abs(this.direction === 'horizontal' ? l : r); var n = Adasha_Utils.constrain((o - this.threshold) * _classPrivateFieldGet(this, _globalParams).invRunoff, 0, 1); if (this.invert && (n = 1 - n), _classPrivateMethodGet(this, _setNodeIndexData, _setNodeIndexData2).call(this, e, 'distance', n), c = s + (n - s) * (Adasha_Utils.XOR(s < n, this.invert) ? this.decay : this.attack), c = Adasha_Utils.roundTo(c, this.accuracy), _classPrivateMethodGet(this, _setNodeIndexData, _setNodeIndexData2).call(this, e, 'lastDelta', c), this.styles.length > 0) { for (var d, u = {}, _ = 0; _ < this.styles.length; _++) { var f = this.styles[_]; var h = this.getNodeIndexData(e, 'styles')[_]; const v = h.near; var P = h.far; const p = f.rules.rule; var h = f.rules.func; var f = f.rules.unit || ''; var P = Adasha_Utils.delta(c, v, P); h ? (u[p] || (u[p] = []), u[p].push(`${h}(${P}${f})`)) : i.style[p] = ''.concat(P).concat(f) } for (d in u) i.style[d] = u[d].join(' '); n = Math.floor(1e3 * c); i.style.zIndex = this.invert ? n : 1e3 - n } } this.FPS || _classPrivateFieldGet(this, _coords) || _classPrivateMethodGet(this, _refresh, _refresh2).call(this) } }]), s
}()); function _init2() { this.preventCenterCalculations = !1, this.setCenterPoints(), this.update = this.update.bind(this), window.addEventListener('scroll', this.reflowEvent.bind(this)), window.addEventListener('resize', this.reflowEvent.bind(this)), document.addEventListener('mousemove', this.updatePointer.bind(this)), document.dispatchEvent(new MouseEvent('mousemove')), this.dispatchEvent(new Event('ready')), this.FPS = _classPrivateFieldGet(this, _globalParams).FPS, window.requestAnimationFrame(this.update) } function _setNodeIndexData2(t, e, a) { return _classPrivateFieldGet(this, _nodeData)[t] || (_classPrivateFieldGet(this, _nodeData)[t] = {}), _classPrivateFieldGet(this, _nodeData)[t][e] = a, _classPrivateFieldGet(this, _nodeData)[t] } function _calculateJitters2() { for (let t = this.jitterMethod || _classPrivateFieldGet(this, _DEFAULT_JITTER_METHOD), e = 0; e < this.nodes.length; e++)_classPrivateMethodGet(this, _setNodeIndexData, _setNodeIndexData2).call(this, e, 'jitter', { x: Adasha_Utils.random(this.jitter + this.jitterX, t), y: Adasha_Utils.random(this.jitter + this.jitterY, t) }); this.preventCenterCalculations || this.setCenterPoints() } function _runFrames2() { const t = Math.round(1e3 / this.FPS); _classPrivateFieldSet(this, _fpsTimerRef, window.setInterval(this.update, t)) } function _refresh2() { window.requestAnimationFrame(this.update), this.dispatchEvent(new Event('redraw')) } var Adasha_Utils = _createClass(function t() { _classCallCheck(this, t) }); _defineProperty(Adasha_Utils, 'constrain', (t, e, a) => { return typeof t != 'number' ? NaN : (e != null && typeof e == 'number' && (t = Math.max(t, e)), a != null && typeof a == 'number' ? Math.min(t, a) : t) }), _defineProperty(Adasha_Utils, 'roundTo', function (t) { const e = ((arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0) + 1) ** 10; return Math.round(t * e) / e }), _defineProperty(Adasha_Utils, 'delta', (t, e, a) => { return (a - e) * Adasha_Utils.constrain(t, 0, 1) + e }), _defineProperty(Adasha_Utils, 'map', (t, e, a, i, s) => { return (t - e) * (s - i) / (a - e) + i }), _defineProperty(Adasha_Utils, 'random', function () { const t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 2; switch (arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 'uniform') { case 'gaussian': case 'normal': for (var e = 0, a = 0; a < 6; a++)e += (Math.random() - 0.5) * t; return e / 6; case 'uniform': default: return (Math.random() - 0.5) * t } }), _defineProperty(Adasha_Utils, 'XOR', (t, e) => { return (t || e) && !(t && e) }), _defineProperty(Adasha_Utils, 'pythagoras', (t, e) => { return Math.sqrt(t * t + e * e) }), _defineProperty(Adasha_Utils, 'isVisibleInViewport', (t) => { const e = t.getBoundingClientRect(); var t = document.documentElement; return e.right >= 0 && e.left <= t.clientWidth && e.bottom >= 0 && e.top <= t.clientHeight }), _defineProperty(Adasha_Utils, 'valToObj', function (t) { const e = {}; return e[arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 'value'] = t, e }), _defineProperty(Adasha_Utils, 'isObject', (t) => { return t == Object(t) })
